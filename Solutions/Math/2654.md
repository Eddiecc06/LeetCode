# 2654. Minimum Number of Operations to Make All Array Elements Equal to 1
[Medium](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/)

## Problem Description

You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:

Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.
Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.

The gcd of two integers is the greatest common divisor of the two integers.


**Example 1**:
```
Input: nums = [2,6,3,4]
Output: 4
Explanation: We can do the following operations:
- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].
- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].
- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].
- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].
```
**Example 2**:
```
Input: nums = [2,10,6,14]
Output: -1
Explanation: It can be shown that it is impossible to make all the elements equal to 1.

```

**Constraints**
```
2 <= nums.length <= 50
1 <= nums[i] <= 10^6
```

## Solution

### _Related Topic_
   Array, Math, Number Theory

### _C++ Code_
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums) {
        //num1 : The counts of '1' in the array 'nums'
        int n = nums.size(), num1 = 0, g = 0;
        for(int num : nums){
            if(num == 1)
                ++num1;
            //replace num[i] as the gcd of num[i] & num[i-1]
            g = Calculate_gcd(g, num);
        }
        // 1 exists in the array. Make all elements in the array equal to 1 with steps (n - num1)
        if (num1 > 0)
            return n - num1;

        //The gcd of all numbers in nums is greater than 1, it is impossible to make all elements in the array equal to 1.
       if (g > 1)
            return -1;
    

        int min_steps = n;
        //First, we find the minimum number of operations to obtain a '1' in the array.
        //Then ,the remaining number can be changed to '1' by doing (n - 1) times operations
        for(int i = 0; i < n; ++i){
            int g = 0;
            for(int j = i; j < n; ++j){
                g = Calculate_gcd(g, nums[j]);
                if(g == 1){
                    min_steps = min(min_steps, j - i );
                    break;
                }
            }
        }
        return min_steps + n - 1;
    }
    int Calculate_gcd(int num1, int num2){
        if(num1 == 0) return num2;
        if(num2 == 0) return num1;
        
        while(num2 != 0){
            int tmp = num2;
            num2 = num1 % num2;
            num1 = tmp;
        }
        return num1;
    }
};


```

### _Complexity Anlysis_
- _Time Complexity_: O(n^2*logM)
- _Space Complexity_ï¼šO(1)
