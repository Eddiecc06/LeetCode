# 3690. Split and Merge Array Transformation
[Medium](https://leetcode.com/problems/split-and-merge-array-transformation/description/)

## Problem Description

You are given two integer arrays nums1 and nums2, each of length n. You may perform the following split-and-merge operation on nums1 any number of times:

  1. Choose a subarray nums1[L..R].
  2. Remove that subarray, leaving the prefix nums1[0..L-1] (empty if L = 0) and the suffix nums1[R+1..n-1] (empty if R = n - 1).
  3. Re-insert the removed subarray (in its original order) at any position in the remaining array (i.e., between any two elements, at the very start, or at the very end).

Return the minimum number of split-and-merge operations needed to transform nums1 into nums2.

**Example 1**:
```
Input: nums1 = [3,1,2], nums2 = [1,2,3]

Output: 1

Explanation:

Split out the subarray [3] (L = 0, R = 0); the remaining array is [1,2].
Insert [3] at the end; the array becomes [1,2,3].
```
**Example 2**:
```
Input: nums1 = [1,1,2,3,4,5], nums2 = [5,4,3,2,1,1]

Output: 3

Explanation:

Remove [1,1,2] at indices 0 - 2; remaining is [3,4,5]; insert [1,1,2] at position 2, resulting in [3,4,1,1,2,5].
Remove [4,1,1] at indices 1 - 3; remaining is [3,2,5]; insert [4,1,1] at position 3, resulting in [3,2,5,4,1,1].
Remove [3,2] at indices 0 - 1; remaining is [5,4,1,1]; insert [3,2] at position 2, resulting in [5,4,3,2,1,1].
```

**Constraints**
```
2 <= n == nums1.length == nums2.length <= 6
-10^5 <= nums1[i], nums2[i] <= 10^5
nums2 is a permutation of nums1.
```

## Solution

### _Related Topic_
   Breadth-first search, queue, hash table

### _C++ Code_
```cpp
class Solution {
public:
    int minSplitMerge(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        //visited : Record the array has been checked
        set<vector<int>> visited;
        //Record the needed move to form a new array
        queue<pair<vector<int>, int>> q;
        q.push({nums1, 0});
        visited.insert(nums1);
        //Generate all possible array after performing the split-and-merge operation on nums1 until transforming nums1 into nums2
        while (!q.empty()){
            auto [cur, steps] =  q.front();
            q.pop();
            //Find the minimum possible steps to transform nums1 to nums2
            if (cur == nums2)
                return steps;
        
            // Try all possible (L, R) subarrays
            for(int i = 0; i < n; ++i){
                for(int j = i; j < n; ++j){
                    vector<int> remain;
                    vector<int> subArray(cur.begin() + i, cur.begin() + j + 1);
                    remain.insert(remain.end(), cur.begin(), cur.begin() + i);
                    remain.insert(remain.end(), cur.begin() + j + 1, cur.end());

                    //Insert the subarray into all possible positions to form a new array
                    for(int k = 0; k <= remain.size(); ++k){
                        if(k == i) // If k = i, we'll get the same array. Don't need to check it
                            continue;
                        vector<int> newArray = remain;
                        newArray.insert(newArray.begin() + k, subArray.begin(), subArray.end());
                        if(!visited.count(newArray)){
                            visited.insert(newArray);
                            q.push({newArray, steps + 1});
                        }
                    }
                }
            }
        }
        
        return -1;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n^2)
- _Space Complexity_ï¼šO(n^2)
