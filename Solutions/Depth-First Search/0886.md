# 886. Possible Bipartition
[Medium](https://leetcode.com/problems/possible-bipartition/description/?envType=problem-list-v2&envId=union-find)

## Problem Description

We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.

Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.


**Example 1**:
```
Input: n = 4, dislikes = [[1,2],[1,3],[2,4]]
Output: true
Explanation: The first group has [1,4], and the second group has [2,3].
```
**Example 2**:
```
Input: n = 3, dislikes = [[1,2],[1,3],[2,3]]
Output: false
Explanation: We need at least 3 groups to divide them. We cannot put them in two groups.
```

**Constraints**
```
1 <= n <= 2000
0 <= dislikes.length <= 10^4
dislikes[i].length == 2
1 <= ai < bi <= n
All the pairs of dislikes are unique.
```

## Solution

### _Related Topic_
   Depth-First Search, Union Find, Graph

### _C++ Code_
```cpp
class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        vector<int> color(n+1, 0);
        unordered_map<int, vector<int>> dislike_graph;
        for(int i = 0; i < dislikes.size(); ++i){
            dislike_graph[dislikes[i][0]].push_back(dislikes[i][1]);
            dislike_graph[dislikes[i][1]].push_back(dislikes[i][0]);
        }
        for(int i = 1; i <= n; ++i){
            if(color[i] == 0){
                if(DFS(dislike_graph, color, i, 1) == false)
                    return false;
            }
        }
        return true;
    }
    bool DFS(unordered_map<int, vector<int>> &dislike_graph, vector<int> &color, int index, int cur_color){
        //cout<<index<<" before color = "<<color[index]<<endl;
        if(color[index] != 0)
            return false;
        color[index] = cur_color;
        //cout<<index<<" after color = "<<color[index]<<endl;
        for(int next_index : dislike_graph[index]){
            if(color[next_index] == 0 && DFS(dislike_graph, color, next_index, -cur_color) == false)
                return false;
            if(color[index] == color[next_index])
                return false;
        }
        return true;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n)
- _Space Complexity_ï¼šO(n)
