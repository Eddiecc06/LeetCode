# 110. Balanced Binary Tree


## Problem Description

Given a binary tree, determine if it is height-balanced.



**Example 1**:

<img width="349" alt="截圖 2023-02-24 下午11 30 22" src="https://user-images.githubusercontent.com/18256877/221219174-2884b2f1-58fe-46b5-9ef8-7deaf8f32c71.png">

```
Input: root = [3,9,20,null,null,15,7]
Output: true
```

**Example 2**:

<img width="412" alt="截圖 2023-02-24 下午11 30 32" src="https://user-images.githubusercontent.com/18256877/221219261-a6589725-c175-4173-a83c-3be1ab6b8878.png">

```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
```
**Example 3**:
```
Input: root = []
Output: true
```

**Constraints**
```
The number of nodes in the tree is in the range [0, 5000].
-10^4 <= Node.val <= 10^4
```

## Solution

### _Related Topic_
   Depth-first search, binary tree

### _C++ Code_
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode *root) {
        if(!root)
            return true;
        if(abs(GetDepth(root->left) -  GetDepth(root->right)) > 1)
            return false;
        return isBalanced(root->left) && isBalanced(root->right);

    }
    int GetDepth(TreeNode *root){
        if(!root)
            return 0;
        return 1 + max(GetDepth(root->left), GetDepth(root->right));
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(N)
- _Space Complexity_：O(N)
