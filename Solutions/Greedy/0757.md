# 757. Set Intersection Size At Least Two
[Hard](https://leetcode.com/problems/set-intersection-size-at-least-two/description/)

## Problem Description

You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively.

A containing set is an array nums where each interval from intervals has at least two integers in nums.

  - For example, if intervals = [[1,3], [3,7], [8,9]], then [1,2,4,7,8,9] and [2,3,4,8,9] are containing sets.

Return the minimum possible size of a containing set.

**Example 1**:
```
Input: intervals = [[1,3],[3,7],[8,9]]
Output: 5
Explanation: let nums = [2, 3, 4, 8, 9].
It can be shown that there cannot be any containing array of size 4.
```
**Example 2**:
```
Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
Output: 3
Explanation: let nums = [2, 3, 4].
It can be shown that there cannot be any containing array of size 2.
```
**Example 3**:
```
Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
Output: 5
Explanation: let nums = [1, 2, 3, 4, 5].
It can be shown that there cannot be any containing array of size 4.
```

**Constraints**
```
1 <= intervals.length <= 3000
intervals[i].length == 2
0 <= starti < endi <= 10^8
```

## Solution

### _Related Topic_
   Array, Greedy, Sorting

### _C++ Code_
```cpp
class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        //Sort the intervals according the right ends.
        //If the value of right ends are the same, process the one with larger left end since it's defintely covered by another one.
        sort(intervals.begin(), intervals.end(), [&](auto &x, auto &y){
            if(x[1] == y[1])
                return x[0] > y[0];
            return x[1] < y[1];
        });
        int ans = 0;
        //num1 : Record the smaller number which can be covered by current interval
        //num2 : Record the larger number which can be covered by current interval
        int num1 = -1, num2 = -1;
        for(auto &it : intervals){
            int left = it[0], right = it[1];
            // Both num1 and num2 aren't in the interval. Need to update 2 numbers
            //Greedy algorithm. We choose the largest 2 available values
            if(left > num2){ 
                num2 = right;
                num1 = right - 1;
                ans += 2;
            }
            //Only num1 isn't in the interval. Number outside the interval needs to be updated to the largest possible value. 
            else if(left > num1){
                num1 = num2;
                num2 = right;
                ++ans;
            }
        }
        return ans;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(nlogn)
- _Space Complexity_ï¼šO(1)
