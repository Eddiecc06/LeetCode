# 2435. Paths in Matrix Whose Sum Is Divisible by K
[Hard](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/)

## Problem Description

You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.

Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.

**Example 1**:

<img width="434" height="193" alt="截圖 2025-11-26 晚上10 56 39" src="https://github.com/user-attachments/assets/1d2f150d-90d5-4bf5-9738-8f8ab399fbfd" />

```
Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
Output: 2
Explanation: There are two paths where the sum of the elements on the path is divisible by k.
The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.
The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.
```
**Example 2**:

<img width="134" height="90" alt="截圖 2025-11-26 晚上10 56 45" src="https://github.com/user-attachments/assets/543d1500-ecdc-454b-9a10-5f861a5443f4" />

```
Input: grid = [[0,0]], k = 5
Output: 1
Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.
```
**Example 3**:

<img width="239" height="193" alt="截圖 2025-11-26 晚上10 56 51" src="https://github.com/user-attachments/assets/6f51fe80-d34e-4ba2-bb5e-ce1ff92a7320" />

```
Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
Output: 10
Explanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.
```

**Constraints**
```
m == grid.length
n == grid[i].length
1 <= m, n <= 5 * 10^4
1 <= m * n <= 5 * 10^4
0 <= grid[i][j] <= 100
1 <= k <= 50
```

## Solution

### _Related Topic_
   Array, Dynamic Programming, Matrix

### _C++ Code_
```cpp
class Solution {
private:
    const int MOD = 1e9 + 7;
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int m = grid.size(), n = grid[0].size();
        const int mod = 1e9 + 7;
        //dp[i+1][j+1][r] : When we visit the grid[i][j] from grid[0][0], the number of possible paths that we can get the remainder where the sum of elements is divided by k is r
        vector<vector<vector<long long>>> dp(m + 1, vector<vector<long long>>(n + 1, vector<long long>(k, 0)));
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(i == 0 && j == 0){
                    dp[i+1][j+1][grid[i][j] % k] = 1;
                    continue;
                }
                //Get the remainder of current element divivded by k
                int remainder = grid[i][j] % k;
                for(int r = 0; r < k; ++r){
                    //prev_rem : To make the remainder that sum divivded by k is r, the sum excluded grid[i][j] nneds to be (r + k - remainder) % k
                    int prev_rem = (r + k - remainder) % k;
                    dp[i+1][j+1][r] = (dp[i][j+1][prev_rem] + dp[i+1][j][prev_rem]) % mod;
                }
            }
        }
    

        return dp[m][n][0];
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(m*n*k)
- _Space Complexity_：O(m*n*k)
