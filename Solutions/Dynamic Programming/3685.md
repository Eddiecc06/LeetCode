# 3685. Subsequence Sum After Capping Elements
[Medium](https://leetcode.com/problems/subsequence-sum-after-capping-elements/description/)

## Problem Description

You are given an integer array nums of size n and a positive integer k.

An array capped by value x is obtained by replacing every element nums[i] with min(nums[i], x).

For each integer x from 1 to n, determine whether it is possible to choose a subsequence from the array capped by x such that the sum of the chosen elements is exactly k.

Return a 0-indexed boolean array answer of size n, where answer[i] is true if it is possible when using x = i + 1, and false otherwise.

**Example 1**:
```
Input: nums = [4,3,2,4], k = 5

Output: [false,false,true,true]

Explanation:

For x = 1, the capped array is [1, 1, 1, 1]. Possible sums are 1, 2, 3, 4, so it is impossible to form a sum of 5.
For x = 2, the capped array is [2, 2, 2, 2]. Possible sums are 2, 4, 6, 8, so it is impossible to form a sum of 5.
For x = 3, the capped array is [3, 3, 2, 3]. A subsequence [2, 3] sums to 5, so it is possible.
For x = 4, the capped array is [4, 3, 2, 4]. A subsequence [3, 2] sums to 5, so it is possible.
```
**Example 2**:
```
Input: nums = [1,2,3,4,5], k = 3

Output: [true,true,true,true,true]

Explanation:

For every value of x, it is always possible to select a subsequence from the capped array that sums exactly to 3.
```

**Constraints**
```
1 <= n == nums.length <= 4000
1 <= nums[i] <= n
1 <= k <= 4000
```

## Solution

### _Related Topic_
   Dynamic Programming

### _C++ Code_
```cpp
class Solution {
public:
    vector<bool> subsequenceSumAfterCapping(vector<int>& nums, int k) {
        int n = nums.size();
        vector<bool> ans(n, false);
        //Sort the array num with increasing order
        sort(nums.begin(), nums.end());

        //possibleSums[num] : Indicate that if it's possible to get sum 'num' by replacing some elemnts to capping value
        vector<bool> possibleSums(k + 1, false);
        //Initialize.
        possibleSums[0] = true;

        int index = 0, curSum = 0;
        for (int cap = 1; cap <= n; cap++) {
            //First, find the numbers smaller than capping value
            while (index < n && nums[index] <= cap){
                int value = nums[index];
                for(int i = k; i >= value; --i){
                    //If it's possible to get sum 'i - value', it also means that we can get the sum 'i' by adding sortedNums[index]
                    if(possibleSums[i - value] == true){
                        possibleSums[i] = true;
                    }
                }
                curSum += value;
                ++index;
            }
            //(n - index) : The number of elements which value is larger than 'capping value'
            //The value of these elements will be replaced as 'capping value'
            // The maximum sum value is smaller than 'k'. It's impossbile to get k when the array is capped by 'cap'
            if(curSum + (n - index) * cap < k){ 
                ans[cap - 1] = false;
                continue;
            }
            //maxCappedNum : The max. number of elements with value 'cap' to get the sum 'k'
            int maxCappedNum = min((n - index), k / cap);
            for(int j = 0; j <= maxCappedNum; ++j){
                int target = k - j * cap;
                if(target >= 0 && possibleSums[target] == true){
                    ans[cap - 1] = true;
                    break;
                }
            }
        }
        return ans;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(nlogn + n*k)
- _Space Complexity_ï¼šO(k)
