# 3186. Maximum Total Damage With Spell Casting
[Medium](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/description/)

## Problem Description

A magician has various spells.

You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.

It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.

Each spell can be cast only once.

Return the maximum possible total damage that a magician can cast.


**Example 1**:
```
Input: power = [1,1,3,4]

Output: 6

Explanation:

The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.
```
**Example 2**:
```
Input: power = [7,1,6,6]

Output: 13

Explanation:

The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.
```

**Constraints**
```
1 <= power.length <= 10^5
1 <= power[i] <= 10^9
```

## Solution

### _Related Topic_
   Array, Hash Table, Dynamic Programming, Sorting, Counting

### _C++ Code_
```cpp
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        //sorted_power[i] = {a, b} : a is the power of spell and b is the number of spells with the same power 'a'
        vector<pair<long, long>> sorted_power;
        int n = power.size();

        //Sort the power. In the sorted_power array, the minimum spell will be put at the first index
        sort(power.begin(), power.end());        
        for (auto p : power) {
            //A spcell with new power value
            if(sorted_power.empty() || sorted_power.back().first != p){
                sorted_power.push_back({p, 1});
            }
            else
                ++sorted_power.back().second;
        }

        int m = sorted_power.size();
        vector<long long> dp(m, 0);
        dp[0] = sorted_power[0].first * sorted_power[0].second;

        //Find the possible maximum damage 
        for(int i = 1; i < m; ++i){
            //1. Without casting the current spell which power is power[i].
            //2. Without casting all previous spells. Only cast the spells which power is power[i]
            dp[i] = max(dp[i-1], (long long)sorted_power[i].first*sorted_power[i].second);
            //3. Cast current spell and previous possible spells
            //Find a possible largest spell with damage power[j] which can be casted when casting current spell
            int j = 0;
            for(j = i; j >= 0; --j){
                if(sorted_power[i].first - sorted_power[j].first > 2)
                    break;
            }
            if(j >= 0)
                dp[i] = max(dp[i], dp[j] + (long long)sorted_power[i].first*sorted_power[i].second);
        }

        return dp[m-1];
    }

};
```

### _Complexity Anlysis_
- _Time Complexity_: O(nlogn + m^2)
- _Space Complexity_ï¼šO(n)
