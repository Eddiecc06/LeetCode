# 3625. Count Number of Trapezoids II
[Hard](https://leetcode.com/problems/count-number-of-trapezoids-ii/description/)

## Problem Description

You are given a 2D integer array points where points[i] = [xi, yi] represents the coordinates of the ith point on the Cartesian plane.

Return the number of unique trapezoids that can be formed by choosing any four distinct points from points.

A trapezoid is a convex quadrilateral with at least one pair of parallel sides. Two lines are parallel if and only if they have the same slope.

Constraints:


**Example 1**:
```
Input: points = [[-3,2],[3,0],[2,3],[3,2],[2,-3]]
Output: 2
Explanation:
```

<img width="254" height="503" alt="截圖 2025-12-03 晚上10 58 52" src="https://github.com/user-attachments/assets/2616e10d-a9bb-4199-8a9e-f418cfc3edd9" />

```
There are two distinct ways to pick four points that form a trapezoid:
The points [-3,2], [2,3], [3,2], [2,-3] form one trapezoid.
The points [2,3], [3,2], [3,0], [2,-3] form another trapezoid.
```
**Example 2**:
```
Input: points = [[0,0],[1,0],[0,1],[2,1]]
Output: 1
Explanation:
```

<img width="254" height="256" alt="截圖 2025-12-03 晚上10 58 57" src="https://github.com/user-attachments/assets/e415a0ea-6a26-4013-84fb-47e83c8cdbfb" />

```
There is only one trapezoid which can be formed.
```

**Constraints**
```
4 <= points.length <= 500
–1000 <= xi, yi <= 1000
All points are pairwise distinct.
```

## Solution

### _Related Topic_
   Array, Hash Table, Math, Geometry

### _C++ Code_
```cpp
class Solution {
public:
    int countTrapezoids(vector<vector<int>>& points) {
        int n = points.size(), ans = 0;
        unordered_map<float, vector<float>> Slope_To_Intercept;
        unordered_map<int, vector<float>> Mid_To_Slope;

        int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        for(int i = 0; i < n; ++i){
            x1 = points[i][0];
            y1 = points[i][1];
            for(int j = i + 1; j < n; ++j){
                x2 = points[j][0];
                y2 = points[j][1];
                int dx = (x1 - x2), dy = (y1 - y2), mid = 0;
                float slope = 0, intercept = 0;
                slope = (dx == 0) ? 1e9 + 7 : (float)dy / dx;
                intercept = (dx == 0) ? x1 : (float)(y1 * dx - x1 * dy) / dx;
                //Since the value range of x, y is -1000 ~ 1000.  Multiply 10000 to record the mid point
                mid = (x1 + x2) * 10000 + (y1 + y2);
                Slope_To_Intercept[slope].push_back(intercept);
                Mid_To_Slope[mid].push_back(slope);
            }
        }
        //Calculate the umber of possible trapezoids from "Slope_To_Intercept" hash table
        for(auto &[ _, possible_intercept] : Slope_To_Intercept){
            //No more than 1 line with the same scope
            if(possible_intercept.size() == 1)
                continue;
            unordered_map<float, int> counts;
            for(float intercept : possible_intercept)
                ++counts[intercept];
            //sum : Record the number of lines with the same scope and can formed a trapezoids before current visited line.
            int sum = 0;
            for(auto &[__, cnt] : counts){
                ans += sum * cnt;
                sum += cnt;
            }
        }
 
        //Calculate the umber of possible parallelograms from "Mid_To_Slope" hash table
        //Lines with the same midpoint can form a parallelogram.
        for(auto &[__, possible_scope] : Mid_To_Slope){
            //No more than 1 line with the same mid point
            if(possible_scope.size() == 1)
                continue;
            unordered_map<float, int> counts;
            for(float slope : possible_scope)
                ++counts[slope];
            int sum = 0;
            for(auto &[__, cnt] : counts){
                //If it's a parallelogram, the same parallelogram will be counted twice when calculating the number of trapezoids earlier. Therefore, we need to find the number of parallelograms and subtract them.
                ans -= sum * cnt; 
                sum += cnt;
            }
        }

        return ans;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n*n)
- _Space Complexity_：O(n*n)
