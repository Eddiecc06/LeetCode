# 3354. Make Array Elements Equal to Zero
[Medium](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/)

## Problem Description

You are given an integer array nums.

Start by selecting a starting position curr such that nums[curr] == 0, and choose a movement direction of either left or right.

After that, you repeat the following process:

- If curr is out of the range [0, n - 1], this process ends.
- If nums[curr] == 0, move in the current direction by incrementing curr if you are moving right, or decrementing curr if you are moving left.
- Else if nums[curr] > 0:
  - Decrement nums[curr] by 1.
  - Reverse your movement direction (left becomes right and vice versa).
  - Take a step in your new direction.
  
A selection of the initial position curr and movement direction is considered valid if every element in nums becomes 0 by the end of the process.

Return the number of possible valid selections.


**Example 1**:
```
Input: nums = [1,0,2,0,3]

Output: 2

Explanation:

The only possible valid selections are the following:

Choose curr = 3, and a movement direction to the left.
[1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,1,0,3] -> [1,0,1,0,3] -> [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,0,0,2] -> [1,0,0,0,2] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,0].
Choose curr = 3, and a movement direction to the right.
[1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,2,0,2] -> [1,0,2,0,2] -> [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,1,0,1] -> [1,0,1,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [0,0,0,0,0].
```
**Example 2**:
```
Input: nums = [2,3,4,0,4,1,0]
Output: 0
Explanation:
There are no possible valid selections.
```

**Constraints**
```
1 <= nums.length <= 100
0 <= nums[i] <= 100
There is at least one element i where nums[i] == 0.
```

## Solution

### _Related Topic_
   Array, Simulation, Prefix Sum


### _C++ Code_
```cpp
class Solution {
public:
    int countValidSelections(vector<int>& nums) {
        int counts = 0, n = nums.size(), sum = nums[0];
        vector<int> prefixSum(n, 0);

        prefixSum[0] = nums[0];
        for(int i = 1; i < n; ++i){
            prefixSum[i] = prefixSum[i-1] + nums[i];
            sum += nums[i];
        }
        for(int i = 0; i < n; ++i){
            //The sum of two sides numbers are equal.
            if(nums[i] == 0 && prefixSum[i] == (sum - prefixSum[i]) )
                counts += 2;
            // The sum of the two sides numbers differs by 1
            else if(nums[i] == 0 && abs(prefixSum[i] - sum + prefixSum[i]) == 1)
                ++counts;
        }
        return counts;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n)
- _Space Complexity_ï¼šO(n)
