# 1584. Min Cost to Connect All Points
https://leetcode.com/problems/min-cost-to-connect-all-points/description/?envType=daily-question&envId=2023-09-15


## Problem Description

You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.

Return the minimum cost to make all points connected. 

All points are connected if there is exactly one simple path between any two points.


**Example 1**:

<img width="266" alt="截圖 2023-09-16 下午7 25 49" src="https://github.com/Eddiecc06/LeetCode/assets/18256877/d1e7faf4-1c81-4348-a1ba-4518ab80b778">

```
Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
```

<img width="266" alt="截圖 2023-09-16 下午7 25 56" src="https://github.com/Eddiecc06/LeetCode/assets/18256877/3dea473c-15c9-4a37-a2f0-6869608aec36">

```
Explanation: 
We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
```
**Example 2**:
```
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
```

**Constraints**
```
1 <= points.length <= 1000
-10^6 <= xi, yi <= 10^6
All pairs (xi, yi) are distinct.
```

## Solution - Prim's Algorithm

### _Related Topic_
   Array, Union Find, Graph, Minimum Spanning Tree

### _C++ Code_
```cpp
class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size(), minCost = 0;
        int x1, x2, y1, y2, dist;
        vector<bool> visited(n, false);
        unordered_map<int, int> min_distance;
        for(int i = 0; i < n; ++i) {
            min_distance[i] = INT_MAX; // Initialize all distances to infinity
        }
        min_distance[0] = 0; // Start node

        //{manhattan distance of two point, the index of start point}
        //sort from small to large according to manhattan distance
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        //Prim's Algorithm
        while(!pq.empty()){
            auto [cost, point] = pq.top();
            pq.pop();
            if(visited[point] || min_distance[point] < cost)
                continue;
            x1 = points[point][0];
            y1 = points[point][1];
            visited[point] = true;
            minCost += cost;
            for(int i = 0; i < n; ++i){
                if(!visited[i]){
                    x2 = points[i][0];
                    y2 = points[i][1];
                    dist = abs(x1 - x2) + abs(y1 - y2);
                    if(dist < min_distance[i]){
                        min_distance[i] = dist;
                        pq.push({dist, i});
                    }
                }
            }
        }
        return minCost;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n^2(logn))
- _Space Complexity_：O(n)
