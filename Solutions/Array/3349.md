# 3349. Adjacent Increasing Subarrays Detection I
[Medium](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/description/)

## Problem Description

Given an array nums of n integers and an integer k, determine whether there exist two adjacent subarrays of length k such that both subarrays are strictly increasing. Specifically, check if there are two subarrays starting at indices a and b (a < b), where:

  - Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing.
  - The subarrays must be adjacent, meaning b = a + k.

Return true if it is possible to find two such subarrays, and false otherwise.


**Example 1**:
```
Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3

Output: true

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, so the result is true.
```
**Example 2**:
```
Input: nums = [1,2,3,4,4,4,4,5,6,7], k = 5

Output: false
```

**Constraints**
```
2 <= nums.length <= 100
1 < 2 * k <= nums.length
-1000 <= nums[i] <= 1000
```

## Solution

### _Related Topic_
   Array

### _C++ Code_
```cpp
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        // length : The length of current strictly increasing subarray
        //prev_length : The length of previous strictly increasing subarray
        int length = 1, prev_length = 0, ans = 0;
        for(int i = 1; i < n; ++i){
            if(nums[i] > nums[i - 1])
                ++length;
            else{ // Find the adjacent number that isn't strictly increasing
                prev_length = length;
                length = 1;
            }
            //Determine if there're two adjacent strictly increasing subarrays satisfied the condition
            ans = max(ans, min(prev_length, length) );
            //Determine if there's a subarray with length >= 2k
            ans = max(ans, length / 2);
        }
        return ans >= k;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n)
- _Space Complexity_ï¼šO(1)
