# 3195. Find the Minimum Area to Cover All Ones I
[Medium](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i/description/)

## Problem Description

You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.

Return the minimum possible area of the rectangle.

**Example 1**:
```
Input: grid = [[0,1,0],[1,0,1]]
Output: 6
Explanation:
```

<img width="285" height="215" alt="截圖 2025-08-25 晚上10 42 33" src="https://github.com/user-attachments/assets/42b93683-68d1-4fa0-98ad-8768f79524e3" />

```
The smallest rectangle has a height of 2 and a width of 3, so it has an area of 2 * 3 = 6.
```
**Example 2**:
```
Input: grid = [[1,0],[0,0]]
Output: 1
Explanation:
```

<img width="216" height="215" alt="截圖 2025-08-25 晚上10 42 37" src="https://github.com/user-attachments/assets/10d51cae-1b72-4e2b-8d04-f0f6cc732f80" />

```
The smallest rectangle has both height and width 1, so its area is 1 * 1 = 1.
```

**Constraints**
```
1 <= grid.length, grid[i].length <= 1000
grid[i][j] is either 0 or 1.
The input is generated such that there is at least one 1 in grid.
```

## Solution

### _Related Topic_
   Array, Matrix

### _C++ Code_
```cpp
class Solution {
public:
    int minimumArea(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        //top : The index of upper boundary
        //bottom : The index of lower boundary
        //left : The index of left  boundary
        //right : The index of right boundary
        int top = -1, bottom = -1, left = -1, right = -1;
        int ans = 0;
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(grid[i][j] == 1){
                    if(top == -1)
                        top = i;
                    else
                        top = min(top, i);
                    if(bottom == -1)
                        bottom = i;
                    else
                        bottom = max(bottom, i);
                    if(left == -1)
                        left = j;
                    else
                        left = min(left, j);
                    if(right == -1)
                        right = j;
                    else
                        right = max(right, j);
                }
            }
        }
        ans = (bottom - top + 1)*(right - left + 1);
        return ans;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(m*n)
- _Space Complexity_：O(1)
