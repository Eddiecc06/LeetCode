# 777. Swap Adjacent in LR String
[Medium](https://leetcode.com/problems/swap-adjacent-in-lr-string/description/?envType=problem-list-v2&envId=string)

## Problem Description

In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". 

Given the starting string start and the ending string result, return True if and only if there exists a sequence of moves to transform start to result.

**Example 1**:
```
Input: start = "RXXLRXRXL", result = "XRLXXRRLX"
Output: true
Explanation: We can transform start to result following these steps:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX
```
**Example 2**:
```
Input: start = "X", result = "L"
Output: false
```

**Constraints**
```
1 <= start.length <= 10^4
start.length == result.length
Both start and result will only consist of characters in 'L', 'R', and 'X'.
```

## Solution

### _Related Topic_
   Two Pointers, String


### _C++ Code_
```cpp
class Solution {
public:
    bool canTransform(string start, string result) {
        if(start.size() != result.size())
            return false;
        //Two pointers. index1 for start sttring and index2 for result string
        int index1 = 0, index2 = 0;
        int n = start.size();
        while(index1 < n || index2 < n){
            while(index1 < n && start[index1] == 'X')
                ++index1;
            while(index2 < n && result[index2] == 'X')
                ++index2;
            //We've reached the end index of one string while another one hasn't, it means that it's impossible to transform start to result
            //The first non 'X' character isn't the same. It's impossible to transform start to result, either
            if((index1 == n && index2 != n) || (index1 != n && index2 == n) || (start[index1] != result[index2]))
                return false;
            else{
                //'L' can be moved to the front position only.
                //'R' can be moved to the back position only.
                if((start[index1] == 'L' && index1 < index2) || (start[index1] == 'R' && index1 > index2) )
                    return false;
                ++index1;
                ++index2;
            }
        }
        return 1;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(n)
- _Space Complexity_ï¼šO(1)
