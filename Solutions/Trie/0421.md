# 421. Maximum XOR of Two Numbers in an Array
https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/

## Problem Description

Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.


**Example 1**:
```
Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.
```
**Example 2**:
```
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127
```

**Constraints**
```
1 <= nums.length <= 2 * 10^5
0 <= nums[i] <= 2^31 - 1
```

## Solution

### _Related Topic_
   Array, Trie

### _C++ Code_
```cpp
class Solution {
private:
    struct TrieNode {
        TrieNode* bit0;
        TrieNode* bit1;
    };
public:
    void insertNode(TrieNode* root, int num) {
        TrieNode* cur = root;
        //The max. number is 2^31 -1, create Tri Tree from 31-th bit
        for(int i = 31; i >= 0; --i){
            int bit = (num >> i) & 1;
            if(bit == 0){
                if(cur->bit0 == nullptr){  // If there's no child node with bit 0, create it 
                    TrieNode *newNode = new TrieNode();
                    cur->bit0 = newNode;
                }
                cur = cur->bit0;
            }
            else{
                if(cur->bit1 == nullptr){  // If there's no child node with bit 1, create it 
                    TrieNode *newNode = new TrieNode();
                    cur->bit1 = newNode;
                }
                cur = cur->bit1;
            }
        }
    }
    int Findmax(TrieNode* root, int num) {
        TrieNode *cur = root;
        int ans = 0;
        for(int i = 31; i >= 0; --i){
            int bit = (num >> i) & 1;
            if(bit == 1){ 
                if(cur->bit0){ //finding the complement
                    ans += (1 << i);
                    cur = cur->bit0;
                }
                else
                    cur = cur->bit1;
            }
            else if(bit == 0){
                if(cur->bit1){ //finding the complement 
                    ans += (1 << i);
                    cur = cur->bit1;
                }
                else
                    cur = cur->bit0;
            }
        }
        return ans;
    }

    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        TrieNode* root = new TrieNode();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            insertNode(root, nums[i]);    //it will make trie by inserting values
        }
        for (int i = 1; i < n; i++) {
            ans = max(ans, Findmax(root, nums[i]));  //find the necessary complementory values and maximum store
        }
        return ans;
    }
};
```

### _Complexity Anlysis_
- _Time Complexity_: O(nlog2(max(nums))
- _Space Complexity_ï¼šO(n)
